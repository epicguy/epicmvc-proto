// Generated by CoffeeScript 1.4.0
(function() {
  'use strict';

  var FindAttrVal, FindAttrs, ParseFile, camelCase, findStyleVal, findStyles, findVars, mkNm, mkObj, nm_map, sq,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  camelCase = function(input) {
    return input.toLowerCase().replace(/-(.)/g, function(match, group1) {
      return group1.toUpperCase();
    });
  };

  mkNm = function(nm) {
    if (nm.match(/^[a-zA-Z_]$/)) {
      return nm;
    } else {
      return sq(nm);
    }
  };

  mkObj = function(obj) {
    var nm, val;
    return '{' + ((function() {
      var _results;
      _results = [];
      for (nm in obj) {
        val = obj[nm];
        _results.push((mkNm(nm)) + ':' + val);
      }
      return _results;
    })()).join() + '}';
  };

  sq = function(text) {
    return "'" + (text.replace(/'/gm, '\\\'')).replace(/\n/g, '\\n') + "'";
  };

  findStyleVal = function(i, a) {
    var nm, p, parts, s, start, str, top;
    s = 'findStyleVal:';
    top = i;
    start = i;
    while (i < a.length) {
      if ((p = a[i++].trim()) !== '') {
        break;
      }
    }
    if (p === '') {
      return [false];
    }
    if (!(i < a.length)) {
      return [s + 'name', start, i];
    }
    nm = camelCase(p);
    start = i;
    while (i < a.length) {
      if ((p = a[i++].trim()) !== '') {
        break;
      }
    }
    if (!(i < a.length && p === ':')) {
      return [s + 'colon', start, i, nm];
    }
    start = i;
    parts = [];
    while (i < a.length) {
      if ((p = a[i++]) === ';') {
        break;
      }
      parts.push(p);
    }
    if (!(p === ';' || i >= a.length)) {
      return [s + 'semi-colon', start, i, nm];
    }
    str = (parts.join('')).trim();
    return [true, top, i, nm, str];
  };

  findStyles = function(file_info, parts) {
    var good, i, nm, start, str, styles, _ref;
    styles = {};
    i = 0;
    while (i < parts.length) {
      _ref = findStyleVal(i, parts), good = _ref[0], start = _ref[1], i = _ref[2], nm = _ref[3], str = _ref[4];
      if (good === false) {
        break;
      }
      if (good !== true) {
        console.log('STYLE-ERROR - ParseFile:', {
          file_info: file_info,
          parts: parts,
          good: good,
          start: start,
          i: i,
          nm: nm,
          str: str
        });
        continue;
      }
      styles[nm] = (findVars(str)).join('+');
    }
    return styles;
  };

  nm_map = {
    'class': 'className',
    'for': 'htmlFor',
    defaultvalue: 'defaultValue',
    defaultchecked: 'defaultChecked',
    colspan: 'colSpan',
    cellpadding: 'cellPadding',
    cellspacing: 'cellSpacing',
    maxlength: 'maxLength'
  };

  FindAttrVal = function(i, a) {
    var nm, p, parts, quo, start, top, _ref;
    top = start = i;
    while (i < a.length) {
      if ((p = a[i++].trim()) !== '') {
        break;
      }
    }
    if (!(i < a.length)) {
      return [false];
    }
    if (p === '') {
      return ['attr-name', start, i];
    }
    p.toLowerCase();
    nm = (_ref = nm_map[p]) != null ? _ref : p;
    start = i;
    while (i < a.length) {
      if ((p = a[i++].trim()) !== '') {
        break;
      }
    }
    if (p !== '=') {
      if (nm === 'selected' || nm === 'autofocus') {
        return [true, start, i - 1, nm, '=', '"', ['false']];
      }
      return ['equals', start, i, nm];
    }
    start = i;
    while (i < a.length) {
      if ((p = a[i++].trim()) !== '') {
        break;
      }
    }
    if (!(p === '"' || p === "'")) {
      return ['open-quote', start, i, nm, '='];
    }
    quo = p;
    start = i;
    parts = [];
    while (i < a.length) {
      if ((p = a[i++]) === quo) {
        break;
      }
      parts.push(p);
    }
    if (p !== quo) {
      return ['close-quote', start, i, nm, '=', quo];
    }
    return [true, top, i, nm, '=', quo, parts];
  };

  FindAttrs = function(file_info, str) {
    var attr_obj, attr_split, empty, eq, good, i, nm, parts, quo, start, style_obj, _ref;
    str = str.replace(/\sp:([a-zA-Z0-9_]+=)/gm, ' p_$1');
    if ((str.slice(0, 2)) === 'p:') {
      str = 'p_' + str.slice(2);
    }
    attr_split = str.trim().split(/([\s="':;])/);
    empty = attr_split[attr_split.length - 1] === '/' ? '/' : '';
    if (empty === '/') {
      attr_split.pop();
    }
    attr_obj = {};
    i = 0;
    while (i < attr_split.length) {
      _ref = FindAttrVal(i, attr_split), good = _ref[0], start = _ref[1], i = _ref[2], nm = _ref[3], eq = _ref[4], quo = _ref[5], parts = _ref[6];
      if (good === false) {
        break;
      }
      if (good !== true) {
        console.log('ERROR - ParseFile:', {
          file_info: file_info,
          good: good,
          start: start,
          i: i,
          nm: nm,
          eq: eq,
          quo: quo,
          parts: parts,
          str: str
        });
        continue;
      }
      if (nm === 'style') {
        style_obj = findStyles(file_info, parts);
        attr_obj[nm] = mkObj(style_obj);
        continue;
      }
      attr_obj[nm] = (findVars(parts.join(''))).join('+');
    }
    return [mkObj(attr_obj), empty];
  };

  findVars = function(text) {
    var ans, args, custom_hash_part, hash_part, i, last, parts, results, _ref;
    parts = text.split(/&([a-zA-Z0-9_]+\/[^;]{1,60});?/gm);
    results = [];
    if (parts.length === 1) {
      return [sq(parts[0])];
    }
    i = 0;
    while (i < parts.length - 1) {
      if (parts[i].length) {
        results.push(sq(parts[i]));
      }
      args = parts[i + 1].split('/');
      last = args.length - 1;
      if (last !== 1 && last !== 2) {
        _log2('ERROR VarGet:', parts[i + 1]);
        continue;
      }
      _ref = args[last].split('#'), args[last] = _ref[0], hash_part = _ref[1], custom_hash_part = _ref[2];
      ans = last === 1 ? "oE.v2(" + (sq(args[0])) + "," + (sq(args[1])) : "oE.v3(" + (sq(args[0])) + "," + (sq(args[1])) + "," + (sq(args[2]));
      if (hash_part) {
        ans += "," + (sq(hash_part));
      } else {
        if (custom_hash_part) {
          ans += ",''," + (sq(custom_hash_part));
        }
      }
      ans += ')';
      results.push(ans);
      i += 2;
    }
    if (parts[parts.length - 1]) {
      results.push(sq(parts[parts.length - 1]));
    }
    return results;
  };

  ParseFile = function(file_stats, file_contents) {
    var after, after_comment, after_defer, after_script, after_style, after_trim, attrs, base_nm, children, dom_close, dom_entity_map, dom_nms, empty, f, i, is_epic, nm, oi, parts, prev_children, t, tag_names_for_debugger, tag_wait, text, whole_tag, _ref, _ref1;
    f = 'react/E/ParseFile.ParseFile:' + file_stats;
    dom_nms = ['div', 'a', 'span', 'ul', 'li', 'p', 'b', 'i', 'dl', 'dd', 'dt', 'form', 'fieldset', 'label', 'legend', 'button', 'input', 'textarea', 'select', 'option', 'table', 'thead', 'tbody', 'tr', 'th', 'td', 'h1', 'h2', 'h3', 'h4', 'h5', 'img', 'br', 'hr'];
    dom_close = ['img', 'br', 'input', 'hr'];
    dom_entity_map = {
      nbsp: '\u00A0',
      reg: '\u00AE',
      copy: '\u00A9',
      times: '\u22A0'
    };
    after_trim = file_contents.trim();
    after_comment = after_trim.replace(/-->/gm, '\x02').replace(/<!--[^\x02]*\x02/gm, '');
    after_defer = after_comment.replace(/<\/epic:defer>/gm, '\x02').replace(/<epic:defer[^\x02]*\x02/gm, '');
    after_style = after_defer.replace(/<\/style>/gm, '\x02').replace(/<style[^\x02]*\x02/gm, '');
    after_script = after_style.replace(/<\/script>/gm, '\x02').replace(/<script[^\x02]*\x02/gm, '');
    after = after_script;
    after = after.trim();
    parts = after.split(/<(\/?)([:a-z_0-9]+)([^>]*)>/);
    i = 0;
    tag_wait = [];
    children = [];
    while (i < parts.length - 1) {
      text = parts[i].trim().replace(/&([a-z]+);/gm, function(m, p1) {
        if (p1 in dom_entity_map) {
          return dom_entity_map[p1];
        } else {
          return '&' + p1 + ';';
        }
      });
      if (text.length) {
        children.push('React.DOM.span({},' + (findVars(text)).join('+') + ')');
      }
      if (parts[i + 1] === '/') {
        if (!tag_wait.length) {
          throw "[" + file_stats + "] Close tag found when none expected close=" + parts[i + 2];
        }
        _ref = tag_wait.pop(), oi = _ref[0], nm = _ref[1], attrs = _ref[2], prev_children = _ref[3], is_epic = _ref[4];
        if (parts[i + 2] !== parts[oi + 2]) {
          tag_names_for_debugger = {
            open: parts[oi + 2],
            close: parts[i + 2]
          };
          throw "[" + file_stats + "] Mismatched tags open=" + parts[oi + 2] + ", close=" + parts[i + 2];
        }
        if (children.length === 0) {
          whole_tag = nm + '(' + attrs + ')';
        } else if (is_epic) {
          whole_tag = nm + '(' + attrs + ',function(){return [' + (children.join(',')) + ']})';
        } else {
          whole_tag = nm + '(' + attrs + ',' + (children.join(',')) + ')';
        }
        children = prev_children;
        children.push(whole_tag);
      } else {
        empty = '';
        attrs = '{}';
        is_epic = 'epic:' === parts[i + 2].slice(0, 5);
        if (parts[i + 3].length > 0) {
          _ref1 = FindAttrs(file_stats, parts[i + 3]), attrs = _ref1[0], empty = _ref1[1];
        }
        if (is_epic) {
          base_nm = parts[i + 2].slice(5);
          if (base_nm === 'page' || base_nm === 'page_part') {
            empty = '/';
          }
          nm = 'oE.T_' + base_nm;
        } else {
          base_nm = parts[i + 2];
          if (base_nm === 'img' || base_nm === 'br' || base_nm === 'input' || base_nm === 'hr') {
            empty = '/';
          }
          if (__indexOf.call(dom_nms, base_nm) < 0) {
            throw new Error('Unknown tag name ' + base_nm + ' in ' + file_stats);
          }
          nm = 'React.DOM.' + parts[i + 2];
        }
        if (empty === '/') {
          whole_tag = nm + '(' + attrs + ')';
          children.push(whole_tag);
        } else {
          tag_wait.push([i, nm, attrs, children, is_epic]);
          children = [];
        }
      }
      i += 4;
    }
    if (tag_wait.length) {
      throw "[" + file_stats + "] Missing closing tags" + (((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = tag_wait.length; _i < _len; _i++) {
          t = tag_wait[_i][0];
          _results.push(parts[t + 2]);
        }
        return _results;
      })()).join(', '));
    }
    if (parts[i].length) {
      children.push((findVars(parts[i])).join('+'));
    }
    text = parts[i].trim();
    if (text.length) {
      children.push('React.DOM.span({},' + (findVars(text)).join('+') + ')');
    }
    _log2(f, file_stats, children);
    return children;
  };

  if (typeof window !== "undefined" && window !== null) {
    window.EpicMvc.Extras.ParseFile$react = ParseFile;
  } else {
    module.exports = function(w) {
      return w.EpicMvc.Extras.ParseFile$react = ParseFile;
    };
  }

}).call(this);
