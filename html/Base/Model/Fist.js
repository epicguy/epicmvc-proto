// Generated by CoffeeScript 1.4.0
(function() {
  'use strict';

  var Fist,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Fist = (function(_super) {

    __extends(Fist, _super);

    function Fist(view_nm, options) {
      this.fist = {};
      Fist.__super__.constructor.call(this, view_nm, options);
    }

    Fist.prototype.eventLogout = function() {
      return true;
    };

    Fist.prototype.event = function(name, act, fistNm, fieldNm, p) {
      var f, field, fist, had_issue, invalidate, invalidate2, tmp_val, was_issue, was_val;
      f = 'event:' + act + '-' + fistNm + '/' + fieldNm;
      _log2(f, p);
      if (name !== 'Fist') {
        BLOWUP();
      }
      fist = this._getFist(fistNm, p.row);
      if (fieldNm) {
        field = fist.ht[fieldNm];
      }
      switch (act) {
        case 'keyup':
        case 'change':
          if (field.type === 'yesno') {
            if (p.val === field.cdata[0]) {
              p.val = field.cdata[1];
            } else {
              p.val = field.cdata[0];
            }
          }
          if (field.hval !== p.val) {
            had_issue = field.issue;
            field.hval = p.val;
            tmp_val = E.fistH2H(field, field.hval);
            E.fistVAL(field, tmp_val);
            if (act === 'change' || had_issue !== field.issue) {
              invalidate = true;
            }
          }
          break;
        case 'blur':
          was_val = field.hval;
          was_issue = field.issue;
          field.hval = E.fistH2H(field, field.hval);
          E.fistVAL(field, field.hval);
          _log2(f, 'invalidate?', was_val, field.hval, was_issue, field.issue);
          if (was_val !== field.hval || was_issue !== field.issue) {
            invalidate = true;
          }
          break;
        case 'focus':
          if (fist.fnm !== fieldNm) {
            fist.fnm = fieldNm;
          }
          break;
        default:
          return Fist.__super__.event.call(this, name, act, fistNm, fieldNm, p);
      }
      invalidate2 = this.confirm(fist, field, act);
      if (invalidate || invalidate2) {
        if (p.async !== true) {
          this.invalidateTables([fist.rnm]);
        } else {
          delete this.Table[fist.rnm];
        }
      }
    };

    Fist.prototype.confirm = function(fist, field, act) {
      var check, src, tar, tval, val, was_issue, was_val;
      if (!((field.confirm != null) || (field.confirm_src != null))) {
        return false;
      }
      tar = field.confirm_src != null ? field : fist.ht[field.confirm];
      src = fist.ht[tar.confirm_src];
      if (tar.issue != null) {
        if (src.issue != null) {
          delete src.issue;
          return true;
        }
        return false;
      }
      was_val = src.hval;
      if (was_val === '' && src.fieldNm !== field.fieldNm) {
        return false;
      }
      was_issue = src.issue;
      val = E.fistH2H(tar, was_val);
      tval = E.fistH2H(tar, tar.hval);
      if (val === tval) {
        delete src.issue;
      } else {
        check = 'FIELD_ISSUE' + (src.issue_text ? '_TEXT' : '');
        this._makeIssue(check, src);
      }
      return was_issue !== src.issue;
    };

    Fist.prototype._makeIssue = function(check, field) {
      var token, _ref;
      token = check;
      if ('A' !== E.type_oau(token)) {
        token = [token, field.nm, (_ref = field.label) != null ? _ref : field.nm, field.issue_text];
      }
      field.issue = new E.Issue(field.fistNm, field.nm);
      return field.issue.add(token[0], token.slice(1));
    };

    Fist.prototype.fistClear = function(fistNm, row) {
      var rnm;
      rnm = fistNm + (row ? ':' + row : '');
      return delete this.fist[rnm];
    };

    Fist.prototype.fistValidate = function(ctx, fistNm, row) {
      var ans, errors, f, field, fieldNm, fist, invalidate, nm, r, _ref, _ref1, _ref2;
      f = 'fistValidate:' + fistNm + (row != null ? ':' + row : '');
      _log2(f);
      r = ctx;
      fist = this._getFist(fistNm, row);
      errors = 0;
      _ref = fist.ht;
      for (fieldNm in _ref) {
        field = _ref[fieldNm];
        if (true !== E.fistVAL(field, field.hval)) {
          errors++;
        }
      }
      _ref1 = fist.ht;
      for (fieldNm in _ref1) {
        field = _ref1[fieldNm];
        if (field.confirm != null) {
          if (true === this.confirm(fist, field, 'fistValidate')) {
            errors++;
          }
        }
      }
      if (errors) {
        invalidate = true;
        r.fist$success = 'FAIL';
        r.fist$errors = errors;
      } else {
        r.fist$success = 'SUCCESS';
        ans = r[fist.nm] = {};
        _ref2 = fist.db;
        for (nm in _ref2) {
          field = _ref2[nm];
          ans[nm] = E.fistH2D(field, field.hval);
        }
      }
      _log2(f, 'result', r, ans);
      if (invalidate === true) {
        this.invalidateTables([fist.rnm]);
      }
    };

    Fist.prototype.loadTable = function(tbl_nm) {
      var Control, Field, any_req, baseFistNm, field, fieldNm, fist, ix, row, _i, _len, _ref, _ref1;
      _ref = tbl_nm.split(':'), baseFistNm = _ref[0], row = _ref[1];
      fist = this._getFist(baseFistNm, row);
      Field = {};
      Control = [];
      any_req = false;
      _ref1 = fist.sp.FIELDS;
      for (ix = _i = 0, _len = _ref1.length; _i < _len; ix = ++_i) {
        fieldNm = _ref1[ix];
        field = fist.ht[fieldNm];
        row = this._makeField(fist, field, ix, row);
        if (row.req) {
          any_req = true;
        }
        Field[fieldNm] = [row];
        Control.push(row);
      }
      return this.Table[tbl_nm] = [
        {
          Field: [Field],
          Control: Control,
          any_req: any_req
        }
      ];
    };

    Fist.prototype._makeField = function(fist, field, ix, row) {
      var choice_type, choices, defaults, f, fl, rows, s, _i, _ref, _ref1, _ref2;
      f = '_makeField';
      defaults = {
        is_first: ix === 0,
        focus: fist.fnm === field.nm,
        yes_val: 'X',
        req: false,
        "default": '',
        width: '',
        size: '',
        issue: '',
        value: '',
        selected: false,
        name: field.nm
      };
      fl = E.merge(defaults, field);
      _ref = fl.type.split(':'), fl.type = _ref[0], choice_type = _ref[1];
      fl.id = 'U' + E.nextCounter();
      fl.value = field.hval;
      if (fl.type === 'yesno') {
        if ((_ref1 = fl.cdata) == null) {
          fl.cdata = ['1', '0'];
        }
        fl.yes_val = String(fl.cdata[0]);
        if (fl.value === fl.yes_val) {
          fl.selected = true;
        } else {
          fl.value = fl.cdata[1];
        }
      }
      if (field.issue) {
        fl.issue = field.issue.asTable()[0].issue;
      }
      if (fl.type === 'radio' || fl.type === 'pulldown') {
        choices = this._getChoices(choice_type, fist, field, row);
        rows = [];
        s = '';
        for (ix = _i = 0, _ref2 = choices.options.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; ix = 0 <= _ref2 ? ++_i : --_i) {
          s = choices.values[ix] === (String(fl.value));
          rows.push({
            option: choices.options[ix],
            value: choices.values[ix],
            selected: s
          });
          fl.Choice = rows;
        }
      }
      return fl;
    };

    Fist.prototype._getFist = function(p_fist, p_row) {
      var db_value_hash, f, field, fieldNm, fist, nm, rec, rnm, _i, _len, _ref, _ref1, _ref2, _ref3;
      f = '_getFist:' + p_fist + (p_row != null ? ':' + p_row : '');
      rnm = p_fist + (p_row ? ':' + p_row : '');
      if (!(rnm in this.fist)) {
        fist = {
          rnm: rnm,
          nm: p_fist,
          row: p_row,
          ht: {},
          db: {},
          st: 'new',
          sp: E.fistDef[p_fist]
        };
        _log2(f, 'new fist', fist);
        E.option.fi1(fist);
        _ref = fist.sp.FIELDS;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fieldNm = _ref[_i];
          field = E.merge({}, E.fieldDef[fieldNm], {
            nm: fieldNm,
            fistNm: p_fist,
            row: p_row
          });
          field.h2h = (function() {
            switch (E.type_oau(field.h2h)) {
              case 'S':
                return field.h2h.split(/[:,]/);
              case 'A':
                return field.h2h;
              default:
                return [];
            }
          })();
          E.option.fi2(field, fist);
          fist.ht[fieldNm] = fist.db[field.db_nm] = field;
        }
        _ref1 = fist.ht;
        for (fieldNm in _ref1) {
          rec = _ref1[fieldNm];
          if (rec.confirm != null) {
            fist.ht[rec.confirm].confirm_src = fieldNm;
          }
        }
        this.fist[rnm] = fist;
      } else {
        fist = this.fist[rnm];
      }
      if (fist.st === 'new') {
        db_value_hash = (_ref2 = E[E.appFist(p_fist)]().fistGetValues(p_fist, p_row)) != null ? _ref2 : {};
        _ref3 = fist.db;
        for (nm in _ref3) {
          field = _ref3[nm];
          field.hval = E.fistD2H(field, db_value_hash[nm]);
        }
        fist.st = 'loaded';
      }
      return fist;
    };

    Fist.prototype._getChoices = function(type, fist, field) {
      var opt_col, options, rec, row, val_col, values, wistNm, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      options = [];
      values = [];
      switch (type) {
        case 'array':
          _ref = field.cdata;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            rec = _ref[_i];
            if (typeof rec === 'object') {
              options.push(String(rec[1]));
              values.push(String(rec[0]));
            } else {
              options.push(String(rec));
              values.push(String(rec));
            }
          }
          return {
            options: options,
            values: values
          };
        case 'wist':
          _ref1 = field.cdata.split(':'), wistNm = _ref1[0], val_col = _ref1[1], opt_col = _ref1[2];
          _ref2 = E.Wist(wistNm);
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            row = _ref2[_j];
            options.push(row[opt_col]);
            values.push(row[val_col]);
          }
          return {
            options: options,
            values: values
          };
        case 'custom':
          return E[E.appFist(fist.nm)]().fistGetChoices(fist.nm, field.nm, fist.row);
        default:
          return E.option.fi4(type, fist, field);
      }
    };

    return Fist;

  })(E.ModelJS);

  E.fistH2H = function(field, val) {
    var str, _i, _len, _ref;
    val = E.fistH2H$pre(field, val);
    _ref = field.h2h;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      str = _ref[_i];
      val = E['fistH2H$' + str](field, val);
    }
    return val;
  };

  E.fistH2H$pre = function(field, val) {
    return val;
  };

  E.fistH2D = function(field, val) {
    if (field.h2d) {
      return E['fistH2D$' + field.h2d](field, val);
    } else {
      return val;
    }
  };

  E.fistD2H = function(field, val) {
    var _ref;
    if (field.d2h) {
      return E['fistD2H$' + field.d2h](field, val);
    } else {
      return (_ref = val != null ? val : field["default"]) != null ? _ref : '';
    }
  };

  E.fistVAL = function(field, val) {
    var check, token, _ref, _ref1, _ref2;
    delete field.issue;
    check = true;
    E.option.fi3(field, val);
    if (val.length === 0) {
      if (field.req === true) {
        check = field.req_text ? ['FIELD_EMPTY_TEXT', field.nm, (_ref = field.label) != null ? _ref : field.nm, field.req_text] : ['FIELD_EMPTY', field.nm, (_ref1 = field.label) != null ? _ref1 : field.nm];
      }
    } else {
      if (field.validate) {
        check = E['fistVAL$' + field.validate](field, val);
        if (check === false) {
          check = 'FIELD_ISSUE' + (field.issue_text ? '_TEXT' : '');
        }
      }
    }
    if (check !== true) {
      token = check;
      if ('A' !== E.type_oau(token)) {
        token = [token, field.nm, (_ref2 = field.label) != null ? _ref2 : field.nm, field.issue_text];
      }
      field.issue = new E.Issue(field.fistNm, field.nm);
      field.issue.add(token[0], token.slice(1));
    }
    return check === true;
  };

  E.fistVAL$test = function(field, val) {
    var re;
    re = field.validate_expr;
    if (typeof re === 'string') {
      re = new RegExp(re);
    }
    return re.test(val);
  };

  E.Model.Fist$Base = Fist;

}).call(this);
