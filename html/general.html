<h2>EpicMvc Documentation (DRAFT)</h2>
<div style="margin-left: 40px;">
<ul>
  <li><a href="#quick_tags">Quick reference to tags</a></li>
</ul>
</div>

<h3 style="margin-left: 40px;">Overview of the architecture (basic concepts)</h3>
<div style="margin-left: 40px;">
<ul>
  <li><a href="#what_epic">What is 'EpicMvc'?</a>
  </li>
  <li><a href="#what_files">Organization of files on disk</a>
  </li>
  <li><a href="#what_controller">What is the 'Controller'?</a></li>
  <li><a href="#what_classes">
What are 'Classes' (Models)?</a></li>
</ul>
</div>

<h3 style="margin-left: 40px;">What the customer sees (working with HTML)</h3>
<div style="margin-left: 40px;">
<ul>
  <li><a href="#what_tags">EpicMvc TAGS documentation</a></li>
  <li><a href="#what_forms">&nbsp;Creating and Editing FORMS and FORM FIELDS</a></li>
  <li><a href="#what_issues">&nbsp;Mapping ISSUES and MESSAGES to user friendly text</a>
  </li>
</ul>
</div>

<h3 style="margin-left: 40px;">A programmer's view (working with code)</h3>
<div style="margin-left: 40px;">
<ul>
  <li><a href="#what_module">Writing a 'CLASS' (Model) module</a><br>
  </li>
  <li><a href="#what_simple">The 'Simple' application</a></li>
  <li><a href="#what_example">&nbsp;The 'Example' application</a>
  </li>
</ul>
</div>

<h3 style="margin-left: 40px;">Connecting web pages to make applications (Data-driven controller)</h3>
<div style="margin-left: 40px;">
<ul>
  <li><a href="#what_flow">Scripted Page Flow: Turning HTML Pages into applications</a></li>
  <li><a href="#what_builtin">&nbsp;The built-in components (PageFlow, Tag, Form?, debug?, others?)</a>
  </li>
</ul>
</div>

<hr>
<h4><a name="what_epic"></a>
What is 'EpicMvc'?</h4>
<div style="margin-left: 40px;">EpicMvc is a revolutionary architecture that
allows non-programmers control over the "flow" of web pages within a Web-based
application. The concept has its roots in the idea of 'scripting GUI objects'
- much like writing Macros for Microsoft Word. The primary change in the
architecture is to introduce a 'Controller', from the Smalltalk concept of
'Model, View, Controller (MVC), which will 'map' clickable-events within
the HTML to actual JavaScript business logic calls. This 'map' then becomes configurable,
and in the spirit of 'workflow' allows the configurator to determine the
next 'web page' to display based on these events. In addition, because all
JavaScript logic now has a list of 'actions' that can be invoked by the 'Controller',
the configurator is free to script multiple actions (i.e. macros) to simulate
what an end user may have previously done by navigating the site.<br>
</div>

<div style="margin-left: 40px;">
<h4>Motivation</h4>
Much of the development effort involved in creating a web based application
is tied up in the flow of web pages, which must be simultaneously developed
along with the HTML and the core business logic. Introducing a 'controller'
to abstract the flow of web pages from these other two areas of development
(the business logic, and the HTML) has these benefits:<br>
<ul>
  <li>Business logic (JavaScript code) is simpler to read and modify, development cycles are shorter</li>
  <li>Code is more re-usable by being modularized, and organized into 'Classes'</li>
  <li>Non-programmers have the flexibility to configure complex user interactions,
including shortcuts, without the need to perform additional QA cycles</li>
  <li>The requirements cycle is much shorter due to the fact that the required
page-flows do not have to be finalized nor even communicated to the development
staff</li>
</ul>
</div>

<div style="margin-left: 40px;"><h4>Development Cycle Advantages</h4></div>
<div style="margin-left: 40px;">Once the HTML has been disconnected from
the JavaScript Business logic, Product development will no longer need to be closely
in sync with the development of the JavaScript logic. The HTML need only specify
a 'label' for an event within a portion of a web page, and let Product Development
make the final connections to the business logic. By eliminating this dependency
and the need for synchronizing efforts, HTML development can proceed unencumbered
by the JavaScript + DB development work with its own time schedules, risks, and
changing specifications.<br>
</div>

<h4 style="margin-left: 40px;">Simplicity of JavaScript business logic</h4>
<div style="margin-left: 40px;">Today, much of the logic in JavaScript
(or server side logic, such as PHP) is coded
to handle, not only the core business functionality itself, but also the
management of the 'flow' of the web page interface, as well as all the state
handling from one form to the next, or to manage a 'context' - i.e. a logged
in customer or agent.<br>
<br>
</div>

<div style="margin-left: 40px;">The legacy code has references to each sub-page
created by the HTML team, and the names of each button and of each form control.
Cookie values are routinely read and written to, to communicate between different
parts of the same code from web page to web page.<br>
<br>
</div>

<div style="margin-left: 40px;">Additionlay the legacy code
must handle the follwoing to properly process any request: (1) Which button/link that was
pressed on a page (2) the last web page that the user came from (3) the next
web page the user is going to. Within (1), the actual next web page may be
decided based on several factors. Within (2) for any exceptions that occur
in handling the previous web page, a determination is made to flow back to
this page - which is then handled by the last piece of logic (3). Sometimes
there is a failure in (3) which requires a major code change to handle this
'cascading exception' possibility.<br>
<br>
</div>

<div style="margin-left: 40px;">The EpicMvc architecture removes all such references
from the business logic layer, and places it into a 'controller' configuration
file with a simplified syntax. What is left for the developer, is to create and
implement well defined 'actions' and to provide a method for populating table data
referenced by Product developement (designers).<br>
</div>
<br>
<hr>
<h4><br>
</h4>

<h4><a name="what_files"></a>Organization of files on disk</h4>
EpicMvc organizes your web site into 'Package's. To create a package,
place a folder into the /&lt;document-root&gt;/Package/ directory as the name of your package.
In this example, code for JavaScript will reside in: Package/test_abc.
<BR><BR>
The configuration to support the 'controller' portion of EpicMvc is
in the file 'app.coffee'. This file
controls how the web pages flow together, and the MODEL/CLASS names HTML will use
to access the JavaScript logic. It also contains a map of any &lt;<b>epic:link_action</b>&gt;
and &lt;<b>epic:form_action</b>&gt; references, to actual JavaScript business logic calls.
Here is a directory listing of the 'simple' sample application (apache example):<br>
<br>
/usr/local/apache/htdocs<br>
<br>
&nbsp; &nbsp; simple.html<br>
<br>
&nbsp; Package/test_abc<br>
&nbsp; &nbsp; app.coffee<br>
&nbsp; &nbsp; issue.coffee<br>
&nbsp; &nbsp; ta.fist.coffee<br>
<br>
&nbsp; &nbsp; Model/<br>
&nbsp; &nbsp; &nbsp; simple.coffee<br>
<br>
&nbsp; &nbsp; view/<br>
&nbsp; &nbsp; &nbsp; simple.tmpl.html<br>
&nbsp; &nbsp; &nbsp; page/simple.page.html<br>
&nbsp; &nbsp; &nbsp; part/hello.part.html<br>
&nbsp; &nbsp; &nbsp; part/time.part.html<br>
<br>

For details regarding the /view/ directory files, see the topic
<a href="#what_tags_PPT">Assembling "Pages" from page "Parts", and using "Templates"</a>
<hr><br>

<h4><a name="what_controller"></a>What is the 'Controller'?</h4>
This is the portion of EpicMvc that is written as JavaScript code, with the exception
of the base classes that are written to support the JavaScript developer when writing
supporting business logic for an application. The controller is run withing the browser
to simulate web page requests/flow. Each web page has a particular "step" in the
flow of web pages in a given application, and the Controller reads the application's
app.* configuration to determine what actions to take, and what resulting
web page to show in the browser. See the sample applications
<a href="#what_simple">Simple</a> and <a href="#what_example">Example</a>
for examples of using app.conf to create applications from HTML pages and JavaScript business logic.<br>
<br>

<hr>
<h4><a name="what_classes"></a>What are 'Classes'?</h4>
All JavaScript business logic is grouped into 'Classes'. This is where the HTML references
data, and how the 'Controller' using the app.* file maps 'actions' (using
&lt;<b>epic:link_action</b>&gt; and &lt;<b>epic:form_action</b>&gt; tags) to the JavaScript business
logic.<br>
<br>

For example, suppose you wish to display the shopcart contents. This information
is stored in the DB for a particular user. The HTML needs to create a loop
over each line in the shopcart, to display the customer's items, along with
markup for the browser. The tag &lt;<b>epic:foreach</b>&gt; is used, using the attribute
"table=". This attribute requires the view-name of the 'Model' which has
the business logic to load the shopcart from the DB. The JavaScript developer may
write several such classes, for different applications, such as base_cart,
promo_cart, order_entry_cart. The app.* file, for a give application chooses
a view-name to use by the HTML, and makes the appropriate connection to a
JavaScript class (i.e. MODELS: name:'Shopcart', class:'promo_cart')
Now, in the HTML, the shopcart class can be called, and assuming the 'table'
of data is called 'items' the tag might look like: &lt;<b>epic:foreach</b> table="Shopcart/items"&gt;<br>
<br>

In the app.* file, to map an action from HTML to business logic, it is
important to know what view-name is mapped to the class that implements this
action. Using the same shopcart example form above, if the HTML contained:
&lt;<b>epic:link_action</b> action="delete" p:item="&amp;items/row_id;"&gt; - then
the app.* might have this entry:
<pre>CLICKS: delete: call:'Shopcart/remove_item', use_fields:'item'
</pre>
... the view-name 'Shopcart' is used to "connect" the action
from the HTML to the proper JavaScript 'Class.'<br>
<br>

<hr>
<h4><a name="what_tags"></a>EpicMvc TAGS documentation</h4>
<div style="margin-left: 40px; text-align: justify;">
For an overview of where files belong, see the topic
<a href="#what_files">Organization of files on disk</a>.
The three file types (tmpl, page, part) are discussed in the first topic below.
Following that is a list of topics that organize custom tags into groups.
For instance, the &lt;<b>epic:foreach</b>&gt; tag would be found under
"Accessing dynamic data in Tables (using the 'foreach tag')".
All EpicMvc tags are distinct by having the prefix "epic:".
Some examples of actual use in an application can be found in
<a href="#what_simple">The 'Simple' application</a> and
<a href="#what_example">The 'Example' application</a>.<br>
</div>
<br>

<ul style="margin-left: 40px;">
  <li><a href="#what_tags_PPT">Assembling "Pages" from page "Parts", and using "Templates"</a></li>
  <li><a href="#what_tags_DDL">Accessing dynamic data in Lists (using '&amp;' and ';' and 'format')</a></li>
  <li><a href="#what_tags_DDT">Accessing dynamic data in Tables (using the 'foreach' tag)</a></li>
  <li><a href="#what_tags_CL">Creating clickable links</a></li>
  <li><a href="#what_tags_FFB">Forms, form fields, and buttons</a></li>
  <li><a href="#what_tags_IF">Conditional logic ('if' tags)</a></li>
  <li><a href="#what_tags_OT">Other tags (script, comment, define)</a></li>
</ul>
<br>

<hr width="100%" size="2"><br>
<h4><a name="what_tags_PPT"></a>Assembling "Pages" from page "Parts", and using "Templates"</h4>
A single web page in a customer's browser, will begin with a "template",
along with a "page" and any "parts" referenced in the "template" or "page"
file. A single "Template" can be set up for many pages, sometimes for all
pages used by a single application. The 'app.*' controller configuration
file will specify which template file to use, for any set of "pages" being
displayed. The same page can be displayed using different templates, in different
steps of the same applications. Therefore, when writing a 'page' do not assume
what 'template' will be used for it.<br>
<br>

Here is visually what the customer's
browser will receive, using an example from the sample 'Simple' application:
<table border="1" style="width: 50%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(153,153,153);" cellpadding="8" cellspacing="2">
<tbody><tr><td>
      <div style="text-align: center;">simple.tmpl<br clear="all">
      <br>
      </div>
      <div style="text-align: center;">
      <table cellpadding="2" cellspacing="2" border="1" style="text-align: left; margin-left: auto; margin-right: auto; width: 80%; background-color: rgb(204,204,204);">
<tbody><tr><td valign="top">
            <div style="text-align: center;">simple.page<br clear="all">
<br>
            </div>
            <table cellpadding="20" cellspacing="2" border="1" style="text-align: left; width: 80%; background-color: rgb(192,192,192); margin-left: auto; margin-right: auto;">
              <tbody>
                <tr align="center">
                  <td valign="top">hello.part.html<br>
                  </td>
                </tr>
                <tr align="center">
                  <td valign="top">time.part.html<br>
                  </td>
                </tr>
              </tbody>
            </table>
<br>
</td>
</tr></tbody>
      </table>
      <br>
      </div>
</td></tr>

</tbody>
</table>

<br>
A more sophisticated layout, where all pages are surrounded by a basic "heading",
"footing" and a "sidebar", with any text issues in an "issues" part, might
look like this:
<table style="background-color: rgb(192,192,192); width: 50%; text-align: left; margin-left: auto; margin-right: auto; height: 400px;" border="1" cellspacing="2" cellpadding="2">

<tbody><tr align="center"><td>header.part.html</td></tr><tr align="center"><td>issues.part.html</td></tr><tr><td><table style="width: 100%; height: 100%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(204,204,204);" border="1" cellspacing="2" cellpadding="2"><tbody><tr><td style="height: 80%;">sidebar.part.html</td><td style="width: 80%; text-align: center;">(actual page)</td></tr></tbody></table></td></tr><tr align="center"><td>footer.part.html</td></tr></tbody>
</table>

<br>
This template HTML using &lt;<b>epic:page</b>&gt; and &lt;<b>epic:page_part</b>&gt; might look like this:<br>
&lt;table border=0 width="640"&gt;<br>
&nbsp; &lt;tr height=48&gt;&lt;td&gt;&lt;<b>epic:page_part</b> part="header"/&gt;&lt;/td&gt;&lt;/tr&gt;<br>
&nbsp; &lt;tr&gt;&lt;td&gt;&lt;<b>epic:page_part</b> part="issues"/&gt;&lt;/td&gt;&lt;/tr&gt;<br>
&nbsp; &lt;tr&gt;&lt;td&gt;&lt;table&gt;<br>
&nbsp; &nbsp; &lt;tr&gt;&lt;td&gt;&lt;<b>epic:page_part</b> part="sidebar"/&gt;&lt;/td&gt;&lt;td&gt;&lt;<b>epic:page</b>/&gt;&lt;/td&gt;&lt;/tr&gt;<br>
&nbsp; &lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;<br>
&nbsp; &lt;tr height=64&gt;&lt;td&gt;&lt;<b>epic:page_part</b> part="footer"/&gt;&lt;/td&gt;&lt;/tr&gt;<br>
&lt;/table&gt;<br>

<hr width="100%" size="2">
<h4><a name="what_tags_DDL"></a>Accessing dynamic data in Lists (using '&amp;' and ';' and 'format')</h4>
<div style="margin-left: 40px;">To reference data in a one-row (or first row of a) 'table'
without looping through all rows you use three words separated by slashes,
and preceded by an ampersand, and terminated with a semicolon. These rules
are designed to allow you to insert a data value anywhere inside the content
or markup in the HTML (even inside a tag). The three parts of a table-value, are 'view-name',
'table-name' and 'column-name'. These are placed as follows: &amp;view-name/table-name/column-name;
or sometimes as &amp;Model/Table/column;
<h4>Example</h4>
&nbsp;Suppose you want to display the logged in users first name.<br>
<h4>View-name (Model)</h4>
</div>
<div style="margin-left: 40px;">You first need to know what view-name to
use. A veiw-name is linked with the JavaScript 'class' that makes dynamic data available
to the HTML. We can use the sample 'Simple' application, which implements
a single 'class' called 'Simple' and exposes it with the view-name of &nbsp;'Simple'.<br>
<h4>Table name</h4>
Next, you need the name of the 'table' of data values you are interested in.
Typically, the JavaScript developer will create online documentation showing you
which table-names are available for a give view-name. In our case, the
table-name is 'Self' to describe a set of logged-in-user values made available
by this JavaScript class.<br>
<h4>column name</h4>
Within a table row, are a set of items referenced by column-name. You choose an item by using
its column-name as the third 'word' in a reference. In our case, the developer
has called "first name" value: "firstName".<br>
<h4>Putting it all together</h4>
Now, we can place this data table value, into our content, in our HTML. Here is an example:<br>
My name is &amp;Simple/Self/firstName;.<br>
<h4>Advanced formatting</h4>
There are functions defined by the JavaScript programmers which can format a data
value, for use in various places in the HTML. Suppose that a value is going
to be used in a query, but might contain spaces, ampersand, equal sign, etc.:<br>
<br>
<pre>&lt;A HREF="/search.html?keywords=&amp;Search/terms/last_keywords;"&gt;<br></pre>
<br>
The value needs to be formatted for use as a value inside the URL. Assuming
the programmer created the custom function needed, the HTML would specify instead:<br>
<br>
<pre>&lt;A HREF="/search.html?keywords=&amp;Search/terms/last_keywords##url:query_value;"&gt;<br></pre>
<br>
Custom formatting is defined as a function with the name of window.EpicMvc.custom_filter. For example:<br>
<pre>
window.EpicMvc.custom_filter= (val,spec) -&gt;
    [func,p1,p2,p3]= spec.split ':'
    switch func
        when 'age'
            return '' if val is 'null' or val is '0000-00-00' or val is null
            return val unless val?.length
            # [y,m,d]= ( val.split 'T')[0].split '-'
            now= new Date().getTime()
            age=( now- Date.parse val)/( 60* 60* 24* 365.25) # TODO: Not 100% accurate.
            Math.floor age/ 1000
        when 'date'
            return '' if val is 'null' or val is '0000-00-00' or val is null
            return val unless val?.length
            [y,m,d]= ( val.split 'T')[0].split '-'
            if p1 is 'long'
                mmap= ['0', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'June',
                    'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec']
                "#{mmap[ Number m]} #{d}, #{y}"
            else if p1 is 'detail'
                val # TODO
            else if p1 is 'format'
                oDate= moment val
                oDate.format p2.replace /_/g, ':'
            else "#{m}/#{d}/#{y}"
        when 'to_upper'
            val.toUpperCase()
</pre>
<h4>Formatting bult-in's</h4>
Using a single '#' followed by these names, applies the formatting shown below:<br>
<pre>
when 'count' then val?.length
when 'bytes' then window.bytesToSize Number val
when 'uriencode' then encodeURIComponent val
when 'esc' then window.EpicMvc.escape_html val
when 'quo' then ((val.replace /\\/g, '\\\\').replace /'/g, '\\\'').replace /"/g, '\\"'  # Allows an item to be put into single quotes
when '1' then (String val)[0]
when 'lc' then (String val).toLowerCase()
when 'ucFirst'
	str= (String str).toLowerCase()
	str.slice( 0, 1).toUpperCase()+ str.slice 1

</pre>
Additionally either #?. or just #. both without a name, can be used as a conditional to insert content.
For example, to set a class attribte to 'hide' when a value exists:
<pre>class="&amp;Model/Table/item#.hide;"</pre>
or to set 'open' vs. 'closed': <pre>class="&amp;Model/Table/is_open#?.open?closed;"</pre>
Note: the 'dot' can be any char other than '#' and represetns a space char if it occurs again. This is deprecated, and spaces would appear as themselves instead. Also, the '%' is special, and represents the value of the Table/item, for example to create a default value of say 10: <pre>&Model/Table/item#?.%?10;</pre>
</div>
<br>

<hr width="100%" size="2">
<h4><a name="what_tags_DDT"></a>Accessing dynamic data in Tables (using the 'foreach' tag)</h4>
Most dynamic data is provided as multiple rows of values arranged in columns.
These are accessed row-by-row using the &lt;<b>epic:foreach</b> table="Model/Table&gt;
tag. Column values then are referenced in the content using &amp;Table/column;
Many times a particular column value is really a nested table itself. The
nested table is accessed using: &lt;<b>epic:foreach</b> table="Table/column_name_of_nested_table"&gt;
and values are then accessed using &amp;column_name_of_nested_table/column;
- this can be done to any depth. Here is an example of accessing the shipping
rows of an order, and within each shipping row, the item rows, and within
these items, any optional component information (such as doll attributes
on a custom doll):<br>
<br>
&lt;<b>epic:foreach</b> table="OrderStatus/Shipment"&gt;<br>
Shipment #&amp;Shipment/counter; to:&nbsp; &amp;Shipment/first_name; &amp;Shipment/last_name;&lt;br&gt;<br>
&nbsp; &lt;<b>epic:foreach</b> table="Shipment/Items"&gt;<br>
&nbsp; &nbsp; Item #&amp;Items/counter;: &amp;Items/description&lt;br&gt;<br>
&nbsp; &nbsp; &lt;<b>epic:foreach</b> table="Items/Components"&gt;<br>
&nbsp; &nbsp; &nbsp; Add-on: &amp;Components/name;<br>
&nbsp; &nbsp; &lt;/epic:foreach&gt;<br>
&nbsp; &lt;/epic:foreach&gt;<br>
&lt;/epic:foreach&gt;<br>
<br>
The 'alias' attribute allows forcing the name of the 'Table' which may help with view-parts that expect a common name:<br>
&lt;<b>epic:foreach</b> table="OrderStatus/ShipmentAddress" alias="Address"&gt;<br>
&nbsp; &lt;<b>epic:page_part</b> part="show_address"/&gt;<br>
&lt;/epic:foreach&gt;<br>
&lt;<b>epic:foreach</b> table="OrderStatus/BillingAddress" alias="Address"&gt;<br>
&nbsp; &lt;<b>epic:page_part</b> part="show_address"/&gt;<br>
&lt;/epic:foreach&gt;<br>
<br>
Another option shows how variable references can be used in the table="" attribute:<br>
&lt;<b>epic:page_part</b> part="show_address" p:table="ShipmentAddress"/&gt;<br>
&lt;<b>epic:page_part</b> part="show_address" p:table="BillingAddress"/&gt;<br>
Then in the common page part:<br>
&lt;<b>epic:foreach</b> table="OrderStatus/&amp;Tag/part/table;" alias="Address"&gt;<br>
&nbsp; &Address/zip;<br>
&lt;/epic:foreach&gt;<br>
<br>
This tag also exposes "built-in" column names as the rows are iterated over.
The logic shows what and how these columns are calculated, and the values used
(count is the current row index starting from 0):<br>
<pre>
_FIRST: (if count is 0 then 'F' else '')
_LAST:  (if count is tbl.length- 1 then 'L' else '')
_SIZE:  tbl.length
_COUNT: count
_BREAK: (if count+ 1 in break_rows_list then 'B' else '')
</pre>
NOTE: _BREAK is used to support multi-column table output.<br>
'break_rows_list' is driven by the additional foreach tag attributes:
'break_min', 'break_fixed', 'break_at', 'break_even';
See the code for Tag_foreach in Base/Model/TagExe.coffee.<br>
<p class="todo-doc-more">TODO MORE DOCUMENTATION ON _BREAK</p>
<br>

<hr width="100%" size="2">
<h4><a name="what_tags_CL"></a>Creating clickable links</h4>
Links that are outside of forms, can be hyperlinks on text or on images.
For these, we use the tag &lt;<b>epic:link_action</b>&gt;. The HTML must be aware
of the values needed to process an action, and provide these as attributes in the tag along
with an action attribute. If you must pass data in a form, you will instead need
to use a form button within a form, so that the form data will be posted
by the browser. This requires a different tag &lt;<b>epic:form_action</b>&gt; and
this is documented in the next section called <a href="#what_tags_FFB">Forms, form fields, and buttons.<br>
<br>
</a>The &lt;<b>epic:link_action</b>&gt; tag does <span style="text-decoration: underline;">not</span>
require you to specify which page to display next or what code to run, or module to call. The only information needed
is (a) a unique name for this action used later to connect to the business
logic, and (b) any values to pass to that action, Suppose you wish to create
a link in the current application, which will log the user out. This may be
done like this: &lt;<b>epic:link_action</b> action="logout"/&gt; - the app.*
file will contain an &lt;action&gt; reference that maps your action called 'logout'
to the proper JavaScript logic module used to effect a logout. Additionally, the
app.* file will determine which page would naturally be displayed next,
after this occurred. This would allow the configurator using app.* to map logout to a
popup confirm page if desired, rather than effect an immeadiate logout call.
Try to name your actions to indicate what the visible link 'means' and not
what you want to 'happen'.<br>
<br>
TODO
Typically, a link appears inside an &lt;<b>epic:foreach</b>&gt; loop, such that
each link is supposed to reference a different row of data. For example,
suppose you have a list of people to send an email to, and the link is designed
to send an email to just one of those addresses. A combination of the &lt;<b>epic:foreach</b>&gt;
and an &lt;<b>epic:link_action</b>&gt; would be used, however this time a parameter
must be included, which names the recipient. The HTML might look like this:<br>
<br>
&lt;h3&gt;Send email to one of the following:&lt;/h3&gt;<br>
&lt;<b>epic:foreach</b> table="ListMaintainer/Recipients"&gt;<br>
&nbsp; &lt;<b>epic:link_action</b> action="send_email" p:recipient="&amp;Recipients/email;"&gt;&amp;Recipients/email;&lt;/epic:link_action&gt;<br>
&lt;/epic:foreach&gt;<br>
<br>
Later in the app.conf file, there would be a line such as: &lt;click action="send_email"
call="ListMaintainer/send" use_fields="recipient"/&gt;<br>

<hr width="100%" size="2">
<h4><a name="what_tags_FFB"></a>Forms, form fields, and buttons</h4>
Forms are created using &lt;<b>epic:form</b>&gt;, and the fields can typically be
created in the DB, and prototyped with one tag &lt;<b>epic:dyno_form</b>&gt;. Within
a form, the clickable buttons are created using &lt;<b>epic:form_action</b>&gt;.
(To create simple &lt;A&gt; type links, use instead &lt;<a href="#what_tags_CL">epic:link_action</a>&gt;.<br>
<br>
Assuming you have created a form called 'example1' with any number of
fields, and wish to create two separate buttons (do-now, and do-later) the
HTML might look like this:<br>
<br>
&lt;<b>epic:form</b>&gt;&lt;table&gt;&lt;<b>epic:dyno_form</b> form="Form/example1"/&gt;&lt;/table&gt;<br>
&nbsp; &lt;BR&gt;&lt;<b>epic:form_action</b> action="do_now" type="image" src="/g/now.gif" /&gt;<br>
&nbsp; &lt;BR&gt;&lt;<b>epic:form_action</b> action="do_later" type="image" src="/g/later.gif" /&gt;<br>
&lt;/epic:form&gt;<br>
<br>
Notes: &lt;<b>epic:form</b>&gt; will default to 'method="post"'. You may also wish
to add 'forms_used="example1"' to support persistent forms (forms saved and
restored across multiple page requests.) To create a form and form fields
in the DB or edit attributes of those fields, see the topic:
<a href="#what_forms">Creating and Editing FORMS and FORM FIELDS</a>.<br>

<br>
<hr width="100%" size="2">
<h4><a name="what_tags_IF"></a>Conditional logic ('if' tags)</h4>
"If" tags are used to surround a set of markup/content lines so that they may
only be included on certain conditions. Frequently the conditions are buried
in some complex logic, and this causes a few issues. One issue is that the
various conditions being checked are spread throughout the HTML. EpicMvc allows
you to collect all this logic at the top of a file, and supply names for
them, to be used by name later in the file. This way you also
only need to modify the condition in one place for it to be used elsewhere.
Also, you can refer to the same name more than once, which cuts down on complexity,
and lets the computer calculate the result only one time, for use multiple
times in the same http request.<br>
<br>
Typically, a comparison has two operands. If you want to know if a variable
is equal to a certain value, then you have (a) a left side, (b) an operator,
and (c) a right side: left='variable' op='eq' 'right='string value'; In EpicMvc
this is done as follows:<br>
<br>
&lt;<b>epic:if</b> left="&amp;Items/quantity;" right="1" op="eq"&gt; ... &lt;/if&gt;<br>
<br>
Suppose you need to know if the quantity is both &gt;1 and &lt;5? You might
be interested to know that the tag &lt;<b>epic:if</b>&gt; is really a synonym for
&lt;<b>epic:if_all</b>&gt;. There is a corresponding &lt;<b>epic:if_any</b>&gt;. Therefore,
to code for &gt;1 <span style="text-decoration: underline;">and</span> &lt;5, &nbsp;you would do this:<br>
<br>
&lt;<b>epic:if_all</b> left="&amp;Items/quantity;" right="1" op="gt" right="5" op="lt"&gt; ... &lt;/epic:if_all&gt;<br>
<br>
Many times, one wishes to do one thing when true, and another when the 'if'
is false (much like the if-then-else type logic.) The best way to effect
this, is to create a label for the operation, and then use the label in an
if_true and if_false fashion, like this:<br>
<br>
&lt;<b>epic:if_all</b> name="one_to_five" left="&amp;Items/quantity;" right="1" op="ge" right="5" op="le" /&gt;<br>
<br>
Now, you can use the 'name' of 'one_to_five' in these two tags:<br>
<br>
&lt;<b>epic:if_true</b> name="one_to_five"&gt; There are one to five items here &lt;/epic:if_true&gt;<br>
&lt;<b>epic:if_false</b> name="one_to_five"&gt; There are <span style="text-decoration: underline;">not</span> one-to-five items here. &lt;/epic:if_false&gt;<br>
<br>
Note that you can place that first 'epic:if_all' tag way at the top of your
file, so it is in an easy place to modify it later if needed.<br>
<br>
The operators that you can use are as follows:<br>
<br>
<table border="0" style="width: 70%; text-align: left; margin-left: auto; margin-right: auto;" cellpadding="2" cellspacing="2">

<tbody><tr>
      <td valign="top" style="text-align: center;"><span style="font-weight: bold;">Operator</span><br>
      </td>
      <td valign="top"><span style="font-weight: bold;">Meaning</span><br>
      </td>
    </tr>
<tr><td style="text-align: center;">eq </td><td> equal to</td></tr>
<tr><td style="text-align: center;">ne </td><td> not equal to</td></tr>
<tr><td style="text-align: center;">gt </td><td> greater than</td></tr>
<tr><td style="text-align: center;">ge </td><td> greater than or equal to</td></tr>
<tr><td style="text-align: center;">lt </td><td> less than</td></tr>
<tr><td style="text-align: center;">le </td><td> less than or equal to</td></tr>
<tr><td style="text-align: center;">set </td><td> is this variable set with a non-empty value?</td></tr>
<tr><td style="text-align: center;">not_set </td><td> is this variable empty?</td></tr>
<tr><td style="text-align: center;">table_is_empty </td><td> does this table have no rows?</td></tr>
<tr><td style="text-align: center;">table_is_not_empty </td><td> does this table have at least one row?</td></tr>
</tbody>
</table>
<br>
<hr width="100%" size="2">
<h4><a name="what_tags_OT"></a>Other tags (script, comment, define)</h4>
The following additional tags are available:<br>
<br>
&lt;<b>epic:script</b>&gt; put your javascript in here. You can include EpicMvc tags
(such as &lt;<b>epic:foreach</b>&gt;) and variable references. &lt;/epic:script&gt;<br>
<br>
&lt;<b>epic:comment</b>&gt; Comments normally are stripped before sending to the
customer. Use this tag to send the text between the tags. &lt;/epic:comment&gt;<br>
<br>
&lt;<b>epic:define</b> name="cool"&gt;Wow, &nbsp;you just created a new epic tag
called 'cool'. Use it anywhere you use other tags.&lt;/epic:deifine&gt;<br>
<br>
&lt;<b>epic:tag</b> name="cool"/&gt;<br>
<br>

<hr>
<h4><a name="what_forms"></a>
Creating and Editing FORMS and FORM FIELDS</h4>
Forms and form fields can be created in the DB, and then used with the simple
prototyping tag &lt;<b>epic:dyno_form</b>&gt;. Fields are defined independent of
a named form, and later, a form is made by simply listing the various fields
that make up the form, and the order to display them. For any field, you
specify a plethora of information designed to provide all the processing
necessary for filtering between the what the user sees and what the DB will
ultimately store as data for those fields (for forms who's data may be stored,
and retrieved later from the DB.)<br>
There are basically two sets of attributes used to define a field. One set
is primarily visual information affecting the customer (such as form control
type, width, issue text when data is wrong, or required and not supplied,
etc.) The other set of attributes for a field are internal filters to validate
and filter the data. The following is an example of two fields configured
in the DB for use in a login form.<br>
<h4>Visual attributes affecting the customer</h4>
<br>
<table border="1" width="100%" cellpadding="2" cellspacing="2">

<tbody><tr><td>field_nm</td><td>control type</td><td>control data</td><td>label</td><td>width</td><td>max length</td><td>issue text</td><td>required text</td><td>help text</td><td>empty_FL</td><td>default value</td></tr>
<tr><td>wlAcctEmail</td><td>text</td><td><br></td><td>Email</td><td>20</td><td>20</td>
<td>Email address is invalid, (sample: abc@xyz.com)</td><td>You must enter a valid email address<br>
</td><td>helpTxt<br>
</td><td>0<br>
</td><td><br>
</td></tr>
<tr><td>wlAcctPswd</td><td>password</td><td><br></td><td>Password</td><td>20</td><td>20</td>
<td>Password must be letters, numbers.</td><td>A password is required.</td><td>helpTxt<br>
</td><td>0<br>
</td><td><br>
</td></tr>
</tbody>
</table>
<h4>Internal filters to validate and filter the data</h4>
<table border="1" width="100%" cellpadding="2" cellspacing="2">

<tbody><tr><td>field_nm</td><td>tableName</td><td>colName</td><td>validate func</td><td>validate expr</td><td>html2html spec</td><td>html2db func</td><td>html2db expr</td><td>db2html func</td><td>db2html expr</td></tr>
<tr><td>wlAcctEmail</td><td>WL_user</td><td>email</td><td>email</td><td></td><td>trim_spaces: lower_case</td><td valign="top"><br>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top"><br>
      </td>
</tr>
<tr><td>wlAcctPswd</td><td>WL_user</td><td>pswd</td><td>regexp</td><td>[a-zA-Z0-9_]{4,}</td><td>trim_spaces</td><td valign="top"><br>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top"><br>
      </td>
      <td valign="top"><br>
      </td>
</tr>
</tbody>
</table>
<br>
EpicMvc is also able to split single DB values, into multiple form controls,
validate those fields separately, and put the data back together again for
storage into a single DB field, all without any extra effort in the JavaScript
or the HTML.<br>

<hr>
<h4><a name="what_issues"></a>
Mapping ISSUES to user friendly messages</h4>
The JavaScript developer returns all user errors as 'tokens.' These tokens are then
mapped by EpicMvc to user readable text. The DB contains all mapping of issue
tokens, to user text, and allows also for parameters to be included in the
text. For example, if an item is out of stock, but the item name needs to
be included in the error message, then the developer might return the token
"OUT_OF_STOCK" along with a parameter value of "Blues Clues treasure chest".
The map for this issue in the DB might be: "Sorry &amp;value_1; is out of
stock."<br>
<br>
Issues can also be specialized by application, such that the same 'OUT_OF_STOCK'
token can have its own text, when it occurs while placing an item in a wish-list
vs. putting the item in the cart - or when the item goes out of stock after
the user is in the checkout process.<br>
<br>

<hr width="100%" size="2">
<h4><a name="what_module"></a>Writing a 'CLASS" module</h4>

<div style="margin-left: 40px;">
<h4>Creating MODELS for making data available to the HTML</h4>
</div>

<div style="margin-left: 40px;">The JavaScript business logic needs to support the
'views' by making 'data' available to them as a 'model' of that data in memory,
which is then wrapped by the views (via custom tags) with HTML to produce
a particular 'view' of that data. Currently data is made available to HTML
via ROWS_xxx and NAMES_xxx - or via global array variables (i.e. PageInfo.)
The new architecture changes this only slightly, in that these 'data-sets'
must now be placed under a named JavaScript class. Some data is provided directly
by the 'controller' using built-in classes (i.e. 'issues' under 'pageflow'
class.) JavaScript makes these data values available via the methods 'get_model_names'
and 'get_model_row' for data which does not require a 'foreach' tag, and
the methods 'get_table_names' and 'get_table_rows' for data that utilizes
a 'foreach' tag.
<h4>Creating ACTIONS to be invoked as business logic rules</h4>
</div>

<div style="margin-left: 40px;">A JavaScript class also supports the configuration
of a controller to invoke a set of actions by implementing the 'action' method,
which takes an 'action' variable, and an array-set list of arguments. It
returns both an array-set list of results, and a list of issues found, if
any.
<h4>Saving and restoring STATE (data which is persisted between page requests)</h4>
A few 'lifecycle' methods, when implemented in the JavaScript code, allow the controller
to save and restore the state of a JavaScript class and for it to receive a logout
event.<br>
<br>
<h4>Using FORMS</h4>
Typically, using forms means that product development will create forms and
form fields in the DB, and the JavaScript classes will rarely have to filter the
results and will typically only use the posted results. Most of the functionality
need by the HTML is pre-built in to the controller logic, and is 'inherited'
by your JavaScript class with the single statement "inherit form_field_maint". You
can customize the loading of the form from the DB using the method "form_load".<br>
<h4>Example</h4>
</div>

<div style="margin-left: 40px;">&nbsp;An example of a JavaScript class, for e.g.
wishlist, might be 'wl_User'. It makes three actions available 'createUser'
'login' and 'logout' - with 'login' requiring fields defined by the 'wlLogin'
form. This class also exposes its model 'ThisUser' containing a list of attributes
that the view "wishList_header.part.html" later pulls, to display the user's login
name (e.g. &amp;Users/ThisUser/email;).<br>
</div>
<br>
<br>

<hr>
<h4><a name="what_simple"></a>The 'Simple' application TBD</h4>

<hr>
<h4><a name="what_example"></a>The 'Example' application TBD</h4>

<hr>
<h4><a name="what_flow"></a>Scripted Page Flow: Turning HTML Pages into applications</h4>

<hr>
<h4><a name="what_builtin"></a>
The built-in components (PageFlow, Epic?, Form?, debug?, others?)</h4>
TBD
<hr width="100%" size="2"><br>
