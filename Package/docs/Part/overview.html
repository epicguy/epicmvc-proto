<h3>What is EpicMvc?</h3>

<p>EpicMvc is a revolutionary architecture that allows non-programmers control over the "flow" of web pages within a Web-based application. This is achived by making the 'Controller' data-driven (no code) which implements a 'Router' as a hierarchical state machine. The 'View' HTML clickable artifacts are simple lables, which the Controller will 'map' to actual JavaScript business logic calls (in the Models.) Responses from the Model actions allows the Controller to determine the next 'web page' to display based on these events. All JavaScript logic is now a list of 'actions' that can be invoked by the 'Controller', and can be separatly auto-unit-tested without a browser instance. All DOM updates are accomplished via the Mithril difference engine, as is done with React and Angular 4. Models are where the JavaScript lives, and are implemented as a Class with specific methods required by EpicMvc; The concept for these is similar to CQRS - the Views make the queries, and the Controller invokes the commands.</p>
<h4>Summary:</h4>
<table>
<tr><th>Controller</th><td>Data-driven Router as hierarchical state machine. Maps View's actions to Model business logic</td>
<tr><th>View</th><td>Fully templated HTML, which gets data from 'tables' exposed by the Models.</td>
<tr><th>Model</th><td>All JavaScript - holds data, exposes to Views as 'tables' and allows changes via 'actions' invoked by the controller.</td>
</table>

<h3>Motivation</h3>

<p>Much of the development effort involved in creating a web based application is tied up in the flow of web pages, which must be simultaneously developed along with the HTML and the core business logic. Abstracting the <b>flow</b> of web pages from these other two areas of development (the business logic, and the HTML) has these benefits:</p>
<ul>
<li>Business logic (JavaScript code) is simpler to read and modify, development cycles are shorter</li>
<li>Code is more re-usable by being modularized, and organized into 'Classes'</li>
<li>Non-programmers have the flexibility to configure complex user interactions, including shortcuts, without the need to make logic changes or perform additional QA cycles</li>
<li>The requirements cycle is much shorter due to the fact that the required page-flows do not have to be finalized nor even communicated to the development staff</li>
</ul>

<h3>Development Cycle Advantages</h3>

<p>Templating has now become the defacto way to separate concerns between HTML views and Business logic. Going beyond templating by separating the <b>flow</b> adds additional similar advantages. The HTML need only specify a 'label' for an event within a portion of a web page, and let the Controller configuration make the final connections to the business logic. By eliminating this dependency and the need for synchronizing efforts, HTML development can proceed unencumbered by the JavaScript + DB development work with its own time schedules, risks, and changing specifications.</p>

<h3>Simplicity of JavaScript Business Logic</h3>

<p>Today, much of the logic in JavaScript (or server side logic, such as PHP) is coded to handle, not only the core business functionality itself, but also the management of the 'flow' of the web page interface, as well as all the state handling from one form to the next, or to manage a 'context' - i.e. a session data for handling the next request.</p>

<p>The code has references to each sub-page created by the HTML team, and the names of each button and of each form control. Cookie values are routinely read and written to, to communicate between different parts of the same code from web page to web page. Even in single-page-apps (SPAs) the logic typically has enbedded knowlege of what data is needed to display any given page. Spitting or combining pages requires rewriting the business logic.</p>

<p>Additionally this method of coding must handle the following to properly process any request: (1) Which button/link that was pressed on a page (2) the last web page that the user came from (3) the next web page the user is going to. Within (1), the actual next web page may be decided based on several factors. Within (2) for any exceptions that occur in handling the previous web page, a determination is made to flow back to this page - which is then handled by the last piece of logic (3). Sometimes there is a failure in (3) which requires a major code change to handle this 'cascading exception' possibility.</p>

<p>The EpicMvc architecture removes all such references from the business logic layer, and places it into a 'controller' configuration file with a simplified syntax. What is left for the developer, is to create and implement well defined 'actions' and to provide a method for populating table data referenced by the view designers. The Model has no knowledge of web pages nor where in the app it is, nor is it even aware of being inside a browser (other than the need to invoke AJAX calls to talk to a server.</p>

<h3>Architecture Diagram</h3>
<a href="Package/docs/images/EpicDiagram.jpg" target="_blank">
	<img src="Package/docs/images/EpicDiagram.jpg" style="width:100%;">
</a>
