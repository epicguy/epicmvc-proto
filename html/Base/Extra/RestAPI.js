// Generated by CoffeeScript 1.9.2
(function() {
  'use strict';
  var RestAPI;

  RestAPI = (function() {
    function RestAPI(opts) {
      var nm, port, prefix, val, version;
      this.opts = {
        port: '',
        prefix: '',
        version: '',
        proto: '//',
        app_headers: {}
      };
      for (nm in opts) {
        val = opts[nm];
        this.opts[nm] = val;
      }
      port = String(this.opts.port);
      if (port.length) {
        port = ':' + port;
      }
      if (this.opts.prefix.length) {
        prefix = '/' + this.opts.prefix;
      }
      if (this.opts.version.length) {
        version = '/' + this.opts.version;
      }
      this.route_prefix = "" + this.opts.proto + this.opts.host + (port != null ? port : '') + (prefix != null ? prefix : '') + (version != null ? version : '') + "/";
      this.SetToken(false);
    }

    RestAPI.prototype.GetPrefix = function() {
      return this.route_prefix;
    };

    RestAPI.prototype.GetToken = function() {
      return this.token;
    };

    RestAPI.prototype.SetToken = function(token1) {
      this.token = token1;
    };

    RestAPI.prototype.D_Request = function(method, route, data, header_obj_in) {
      var f, header_obj, promise, status;
      f = 'E/RestAPI$Base.D_Request';
      header_obj = E.merge({}, this.opts.app_headers, header_obj_in != null ? header_obj_in : {});
      status = {
        code: false,
        text: false,
        ok: false
      };
      promise = new Promise((function(_this) {
        return function(resolve, reject) {
          var formData, nm, val, xhr;
          xhr = new XMLHttpRequest();
          xhr.onloadend = function(event) {
            var jResponse, response;
            status.code = xhr.status;
            status.text = xhr.statusText;
            status.xhr = xhr;
            if (xhr.status === 200) {
              status.ok = true;
            }
            if (!xhr.responseText.length) {
              status.text = 'NetworkError';
              response = '{"error":"NETWORK_ERROR"}';
            } else {
              response = xhr.responseText;
            }
            jResponse = JSON.parse(response);
            return resolve({
              status: status,
              data: jResponse
            });
          };
          xhr.open(method, _this.route_prefix + route);
          for (nm in header_obj) {
            val = header_obj[nm];
            xhr.setRequestHeader(nm, val);
          }
          formData = new FormData();
          for (nm in data) {
            val = data[nm];
            formData.append(nm, val);
          }
          return xhr.send(formData);
        };
      })(this));
      return promise.then(function(result) {
        console.log(f, result);
        return result;
      });
    };

    RestAPI.prototype.D_Get = function(route, data) {
      return this.D_RequestAuth('GET', route, data);
    };

    RestAPI.prototype.D_Post = function(route, data) {
      return this.D_RequestAuth('POST', route, data);
    };

    RestAPI.prototype.D_Del = function(route, data) {
      return this.D_RequestAuth('DEL', route, data);
    };

    RestAPI.prototype.D_Put = function(route, data) {
      return this.D_RequestAuth('PUT', route, data);
    };

    RestAPI.prototype.D_RequestAuth = function(method, route, data, header_obj_in) {
      var header_obj, token;
      token = this.GetToken();
      if (token === false) {
        setTimeout(function() {
          return E.action('Request.no_token');
        }, 0);
        return Promise.resolve({
          status: {
            code: 401,
            text: 'NO_TOKEN',
            ok: false
          },
          data: {
            error: 'TOKEN'
          }
        });
      }
      header_obj = E.merge({}, this.opts.app_headers, header_obj_in != null ? header_obj_in : {});
      header_obj.Authorization = token.token_type + " " + token.access_token;
      return (this.D_Request(method, route, data, header_obj)).then((function(_this) {
        return function(status_n_data) {
          if (status_n_data.status.code === 401) {
            setTimeout(function() {
              return E.action('Request.bad_token');
            }, 0);
            return {
              status: {
                code: 401,
                text: 'BAD_TOKEN',
                ok: false
              },
              data: {
                error: 'TOKEN'
              }
            };
          }
          return status_n_data;
        };
      })(this));
    };

    return RestAPI;

  })();

  E.Extra.RestAPI$Base = RestAPI;

}).call(this);
